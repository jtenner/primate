module Primate
from "uri" include Uri
from "map" include Map
from "uri" include Uri
from "runtime/gc" include GC as Runtime
from "result" include Result
from "map" include Map
from "json" include Json
from "wasi/file" include File
from "option" include Option
from "list" include List

use Uri.{ type Uri }
use Map.{ type Map }
use Json.{ type Json }
use File.{ type FileDescriptor }

provide record Request {
  url: Uri.Uri,
  body: Map<String, String>,
  path: Map<String, String>,
  query: Map<String, String>,
  headers: Map<String, String>,
  cookies: Map<String, String>,
}

provide let _to_uri = (uri: String) => {
  let uri = Uri.parse(uri)
  Result.expect("invalid URI", uri)
}

provide let _makeRequest = (uri: Uri) => {
  {
    url: uri,
    body: Map.make(),
    path: Map.make(),
    query: Map.make(),
    headers: Map.make(),
    cookies: Map.make(),
  }
}

provide let _decRef = Runtime.decRef
provide let _incRef = Runtime.incRef
provide let _toURI = (uri: String) => {
  let uri = Uri.parse(uri)
  Result.expect("invalid URI", uri)
}

provide let _setRequestBody = (req: Request, key: String, value: String) => {
  Map.set(key, value, req.body)
  void
}
provide let _setRequestPath = (req: Request, key: String, value: String) => {
  Map.set(key, value, req.path)
  void
}
provide let _setRequestQuery = (req: Request, key: String, value: String) => {
  Map.set(key, value, req.query)
  void
}
provide let _setRequestHeaders = (req: Request, key: String, value: String) => {
  Map.set(key, value, req.headers)
  void
}
provide let _setRequestCookies = (req: Request, key: String, value: String) => {
  Map.set(key, value, req.cookies)
  void
}

provide record ViewOptions {
  head: Option<String>,
  partial: Bool,
  placeholders: Map<String, String>,
  page: Option<String>,
  csp: Map<String, String>,
}

provide let makeViewOptions = (
  head: Option<String> = None,
  partial: Bool = false,
  placeholders: Map<String, String> = Map.make(),
  page: Option<String> = None,
  csp: Map<String, String> = Map.make(),
) => {
  let options: ViewOptions = {
    head,
    partial,
    placeholders,
    page,
    csp,
  }
  options
}

provide enum HTTPStatus {
  Ok,
  NotFound,
  InternalServerError,
}

provide record ErrorOptions {
  body: Option<String>,
  status: HTTPStatus,
  page: Option<String>,
}

provide let makeErrorOptions = (
  body: Option<String> = None,
  status: HTTPStatus = NotFound,
  page: Option<String> = None,
) => {
  let options: ErrorOptions = {
    body,
    status,
    page,
  }
  options
}

provide enum Response {
  ResponseString(String),
  ResponseJson(Json),
  ResponseFile(FileDescriptor),
  ResponseView(String, Json, Option<ViewOptions>),
  ResponseError(ErrorOptions),
  ResponseRedirect(String, Option<HTTPStatus>),
  ResponseUri(Uri),
}

provide module Response {
  provide let string = (value: String) => {
    ResponseString(value)
  }
  provide let json = (value: Json) => {
    ResponseJson(value)
  }
  provide let file = (file: FileDescriptor) => {
    ResponseFile(file)
  }
  provide let view = (name: String, props: Json = Json.JsonNull, options: Option<ViewOptions> = None) => {
    ResponseView(name, props, options)
  }
  provide let error = (options: ErrorOptions = makeErrorOptions()) => {
    ResponseError(options)
  }
  provide let redirect = (route: String, status: Option<HTTPStatus> = None) => {
    ResponseRedirect(route, status)
  }
  provide let uri = (uri: Uri) => {
    ResponseUri(uri)
  }
}

provide let _getResponseString = (response: Response) => {
  match (response) {
    ResponseString(value) => Some(value),
    _ => None,
  }
}
provide let _getResponseJson = (response: Response) => {
  match (response) {
    ResponseJson(value) => Some(Json.toString(value)),
    _ => None,
  }
}

// TODO: implemenet file descriptors
// provide let _get_response_file_descriptor =

provide let _getResponseViewName = (response: Response) => {
  match (response) {
    ResponseView(name, _, _) => Some(name),
    _ => None,
  }
}
provide let _getResponseViewProps = (response: Response) => {
  match (response) {
    ResponseView(_, props, _) => Some(Json.toString(props)),
    _ => None,
  }
}
provide let _getResponseViewOptions = (response: Response) => {
  match (response) {
    ResponseView(_, _, options) => Some(options),
    _ => None,
  }
}
provide let _getResponseErrorOptions = (response: Response) => {
  match (response) {
    ResponseError(options) => Some(options),
    _ => None,
  }
}
provide let _getResponseRedirectRoute = (response: Response) => {
  match (response) {
    ResponseRedirect(route, _) => Some(route),
    _ => None,
  }
}
provide let _getResponseRedirectStatus = (response: Response) => {
  match (response) {
    ResponseRedirect(_, status) => status,
    _ => None,
  }
}
provide let _getResponseUri = (response: Response) => {
  match (response) {
    ResponseUri(uri) => Some(uri),
    _ => None,
  }
}

provide let _isResponseString = (res: Response) => {
  match (res) {
    ResponseString(_) => true,
    _ => false,
  }
}
provide let _isResponseJson = (res: Response) => {
  match (res) {
    ResponseJson(_) => true,
    _ => false,
  }
}
provide let _isResponseFile = (res: Response) => {
  match (res) {
    ResponseFile(_) => true,
    _ => false,
  }
}
provide let _isResponseView = (res: Response) => {
  match (res) {
    ResponseView(_, _, _) => true,
    _ => false,
  }
}
provide let _isResponseError = (res: Response) => {
  match (res) {
    ResponseError(_) => true,
    _ => false,
  }
}
provide let _isResponseRedirect = (res: Response) => {
  match (res) {
    ResponseRedirect(_, _) => true,
    _ => false,
  }
}
provide let _isResponseUri = (res: Response) => {
  match (res) {
    ResponseUri(_) => true,
    _ => false,
  }
}

provide let _expectOption = (value: Option<t>) => {
  Option.expect("Expected option value to be some", value)
}

provide let _mapToList = (map: Map<String, String>) => {
  Map.toList(map)
}

provide let _isEmpty = (value: List<t>) => {
  List.isEmpty(value)
}

provide let _listHead = (value: List<t>) => {
  List.head(value)
}

provide let _listTail = (value: List<t>) => {
  List.tail(value)
}

provide let _firstTuple = (value: (String, String)) => {
  let (first, _) = value
  first
}

provide let _secondTuple = (value: (String, String)) => {
  let (_, second) = value
  second
}
